<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>Kongjam</title>
	<style>
	
.container {
	position: absolute;
	width: 100%;
}

@media only screen and (min-width: 800px) {
	.container {
		width: 800px;
	}
}

	</style>

	<script type="text/javascript" src="libs/jquery.min.js"></script>
	<script type="text/javascript" src="libs/three.min.js"></script>
	<script type="text/javascript" src="libs/Detector.js"></script>
	<script type="text/javascript" src="libs/CanvasRenderer.js"></script>
	<script type="text/javascript" src="libs/physi.js"></script>
	<script type="text/javascript" src="libs/Tween.js"></script>
	<script type="text/javascript" src="libs/microcache.js"></script>
	<script type="text/javascript" src="libs/THREEx.KeyboardState.js"></script>

	<!-- Scenes !-->
	<script type="text/javascript" src="scenes/mainScene.js"></script>

	<script type="text/javascript">
<!--
"use strict";

Physijs.scripts.worker	= "libs/physijs_worker.js";
Physijs.scripts.ammo	= "ammo.js";

// GLOBALS
var renderer,
	scene;		// current scene

var requestAnimationFrame = 
	window.requestAnimationFrame || 
	window.mozRequestAnimationFrame || 
	window.webkitRequestAnimationFrame || 
	window.msRequestAnimationFrame;

// Resize offset for full canvas
var renderMarginWide = .015;
var windowAspect = 600 / 800;

var keyboard = new THREEx.KeyboardState();

var SceneManager = (function () {
	return {
		setScene: function (sceneName) {
			scene = new window[sceneName]();
		}
	}
})();

var ResourceManager = (function () {
	var loadingManager;
	var textureLoader,
		cubeTextureLoader,
		JSONLoader;

	var textures = [];
	var cubetextures = [
		{
			name: "starSkybox",
			urls: [
				"images/skybox/1.jpg",
				"images/skybox/2.jpg",
				"images/skybox/3.jpg",
				"images/skybox/4.jpg",
				"images/skybox/5.jpg",
				"images/skybox/6.jpg"
				]
		}
	];
	var models = [];

	function loadResources () {
		textures.forEach(function (element) {
			textureLoader.load(element, function (loadedElement) {
				renderer._textureCache.getSet(
					element 						// cache this item by its filename
						.replace(/^.*[\\\/]/, "")	// remove folders from filename (basename)
						.replace(/\.[^/.]+$/, ""),	// remove extension
					loadedElement
				);
			})
		});

		cubetextures.forEach(function (element) {
			cubeTextureLoader.load(element.urls, function (loadedElement) {
				loadedElement.format = THREE.RGBFormat;
				renderer._textureCache.getSet(
					element.name,
					loadedElement
				);
			})
		});

		models.forEach(function (element) {
			JSONLoader.load(element, function (geometry, materials) {
				renderer._modelCache.getSet(
					element 						// cache this item by its filename
						.replace(/^.*[\\\/]/, "")	// remove folders from filename (basename)
						.replace(/\.[^/.]+$/, ""),	// remove extension
					new THREE.Mesh(geometry, new THREE.MeshFaceMaterial(materials))
				);
			});
		});
	}

	return {
		init: function () {
			loadingManager = new THREE.LoadingManager();
			loadingManager.onLoad = function () {
				SceneManager.setScene("mainScene");
				render();
			};
			loadingManager.onProgress = function (item, loaded, total) {
				self.loadedPercent = loaded / total;
			};

			textureLoader = new THREE.TextureLoader(loadingManager);
			cubeTextureLoader = new THREE.CubeTextureLoader(loadingManager);
			JSONLoader = new THREE.JSONLoader(loadingManager);
			renderer._textureCache = new MicroCache();
			renderer._modelCache = new MicroCache();

			loadResources();
		}
	};
})();

function init () {

	// Renderer
	if (Detector.webgl) {
		renderer = new THREE.WebGLRenderer({
			antialias: true
		});
		renderer.shadowMap.enabled = true;
		renderer.shadowMapSoft = true;
		renderer.shadowMapEnabled = true;
		renderer.shadowMapSoft = true;
		renderer.shadowMapType = THREE.PCFShadowMap;
		renderer.shadowMapAutoUpdate = true;
		renderer.autoClear = false;
		renderer.setClearColor(0x000000);
		renderer.setPixelRatio(window.devicePixelRatio);
	}
	else {
		renderer = new THREE.CanvasRenderer()
	}

	var windowWidth =
		window.innerWidth ||
		document.documentElement.clientWidth ||
		document.body.clientWidth;
	var width = Math.min(windowWidth - (windowWidth * renderMarginWide), 800);
	renderer.setSize(
		width,
		width * windowAspect);
	$(".container").append(renderer.domElement);

	ResourceManager.init();
}

function render (time) {
	renderer.clear();

	var walkingDirection = 0;
	var player = renderer._modelCache.get("player");
	var velocity = player.getLinearVelocity();

	if (!player.userData.isJumping) {
		if (keyboard.pressed("left") || keyboard.pressed("a")) {
			walkingDirection = 1;
		}
		else if (keyboard.pressed("right") || keyboard.pressed("d")) {
			walkingDirection = -1;
		}

		if (walkingDirection != 0) {//			   acceleration				   max speed
			velocity.z = Math.min(Math.max(velocity.z + 10 * walkingDirection, -10), 10);
		}

		if (keyboard.pressed("up") || keyboard.pressed("w")) {
			player.userData.isJumping = true;
			velocity.x += 25;	// jump force
		}
	}
	else {
		if (keyboard.pressed("left") || keyboard.pressed("a")) {
			walkingDirection = 1;
		}
		else if (keyboard.pressed("right") || keyboard.pressed("d")) {
			walkingDirection = -1;
		}

		if (walkingDirection != 0) {//			   acceleration				   max speed
			velocity.z = Math.min(Math.max(velocity.z + 1 * walkingDirection, -10), 10);
		}
	}
	player.setLinearVelocity(velocity);

	if (scene.simulatePhysics) {
		player.setAngularVelocity(new THREE.Vector3( 0, 0, 0 ));
		scene.mainScene.simulate();
	}

	scene.time = time;
	TWEEN.update(time);
	renderer.render(scene.mainScene, scene.mainCamera);

	if(typeof scene.HUDCamera !== typeof undefined && typeof scene.HUDScene !== typeof undefined) {
		renderer.clearDepth();
		renderer.render(scene.HUDScene, scene.HUDCamera);
	}

	// Request and process next frame
	requestAnimationFrame(render);
}


//********//
// Event Handlers

$(window).resize(function () {
	if (typeof renderer !== typeof undefined) {
		var windowWidth =
			window.innerWidth ||
			document.documentElement.clientWidth ||
			document.body.clientWidth;
		var width = Math.min(windowWidth - (windowWidth * renderMarginWide), 800);
		var height = width * windowAspect;
		renderer.setSize(width,	height);
	}

	if (typeof scene !== typeof undefined) {
		scene.mainCamera.aspect = width / height;
		scene.mainCamera.updateProjectionMatrix();
	}
});

$(document).ready(function() {
	init();
});

//-->
	</script>
</head>
<body>
	<div class="container">
	</div>
</body>
</html>